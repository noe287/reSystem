#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <error.h>

// Private Constant Definitions
#define MAX_INST_SIZE           64
#define UI_FX_TIMEOUT           120

#define WPS_OUI_FIXED_HEADER_OFF        16
#define WPS_OUI_HEADER_LEN              2
#define WPS_OUI_HEADER_SIZE             4
#define WPS_OUI_LEN                     3
#define WPS_ID_APP_LIST                 0x1058

#define VNDR_IE_MAX_LEN                 255

#define SCAN_STATUS_NOSCAN      0
#define SCAN_STATUS_INSCAN      1
#define SCAN_STATUS_UNKNOWN     (-1)

#define AUTOMESH_ROUTE_TYPE_DEFAULT       0                                                                                                             
#define AUTOMESH_ROUTE_TYPE_LOCAL         1
#define AUTOMESH_ROUTE_TYPE_LEARNED       2                                                                                                             // Private Macro Definitions

#define ETHER_ADDR_STR_LEN                18 

#define RETURN_ON_ERROR(_ret)                  \
        do {                                   \
                if (ret != 0) {                \
                        printf("ret=%d", ret); \
                        return ret;            \
                }                              \
        } while (0)

#define BAIL_ON_ERROR(_ret)                    \
        do {                                   \
                if (ret != 0) {                \
                        printf("ret=%d", ret); \
                        goto bail;             \
                }                              \
        } while (0)

#if !defined(TAILQ_FOREACH_SAFE)
#define TAILQ_FOREACH_SAFE(var, head, field, next) \
        for ((var) = ((head)->tqh_first); (var) && ((next) = ((var)->field.tqe_next), 1); (var) = (next))
#endif

#ifndef MAC2STR
#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
#endif

#define OTHER_MODIFIER          1008
#define RETRY_SLEEP_SECS        5
#define RETRY_COUNT             3
#define LINE_MAX 1024
#define IFNAMSIZ 10

// copied from amioctl.h
typedef struct route_elem {
        unsigned char destination[6];
        char device[IFNAMSIZ];
        unsigned int short queued;
        unsigned int metric;
        unsigned int age;
        unsigned int idle;
        unsigned int short type;
} route_elem_t;

typedef struct route_list {
        unsigned int count;
        route_elem_t routes[0];
} route_list_t;

static FILE *openRoutesFile(){

          FILE *fp = NULL;
          int ret = 0; 

  	  //proc -> (Viper) 
          fp = fopen("a.txt","r");
          if (fp == NULL) 
                  //dev -> (STB) 
                  fp = fopen("a.txt","r");
	  
	  return fp;
}


int main(int argc, char *argv[])
{
          FILE *fp = NULL;
          int ret = 0; 
          unsigned int len = 0, i = 0, k = 0, lineoffset = 0, num_col = 0, line_count = 0, found_line = 0; 
          char *pline = NULL;
          char line[LINE_MAX]= {0}; 
          char dev[IFNAMSIZ] = {0}; 
          char destMacStr[ETHER_ADDR_STR_LEN] = {0}; 
          int metric = 0; 
          unsigned int age = 0.0, idle = 0.0; 
	  unsigned int type;
	  route_list_t *route_list = NULL;
	  char keys[]="[";                                                                                                                                                                                                                     
	  char str[LINE_MAX] = {0};



	if ((fp = openRoutesFile()) == NULL) {
        	ret = -1;
	        BAIL_ON_ERROR(ret);
	}
       
	//Count the number of entries after the header
	while ((pline = fgets(line, sizeof(line), fp)) != NULL) {
		if (found_line == 0) {
			if (strstr(pline, "hwaddr") != NULL)
				found_line = 1;
		} 
		else {
		  if (line[strlen(line) - 1] == '\n')
			  line_count++;
		}
		
	} 
	
	/* route_list = (struct route_list*) calloc(1, sizeof(route_list_t)); */
	route_list = (struct route_list*) malloc(sizeof(struct route_list) + line_count * sizeof(route_elem_t));
	memset(route_list, 0, sizeof(struct route_list) + line_count * sizeof(route_elem_t));

	printf("lcount:%d\n", line_count);
	route_list->count = line_count;
	printf("route_list:%d\n", route_list->count);
	line_count = 0;
	/* route_list->routes[4].age=10; */

	/* printf("AGE:%d\n", route_list->routes[4].age); */
	/* route_list = (struct route_list*) calloc(1, sizeof(route_list_t)); */
        /* r = calloc(sizeof(struct automesh_ioctl_routes) + s.count * sizeof(struct automesh_ioctl_route)); */

	if ((fp = openRoutesFile()) == NULL) {
        	ret = -1;
	        BAIL_ON_ERROR(ret);
	}

          while ((pline = fgets(line, sizeof(line), fp)) != NULL) {
                  if (lineoffset == 0) { 
                          if (strstr(pline, "hwaddr") != NULL){
                                  lineoffset = 1;
  				  fgets(line, sizeof(line), fp);
				  printf("line:%s\n", line);
		  	  }
                          continue;
                  }
/* dev         id     hwaddr          metric    seq      age     idle [ seq0 / metric0 /devid0][ seq1 / metric1 /devid1][ seq2 / metric2 /devid2] flags */
/* eth1         6  00:50:56:a7:eb:a0       0    247      0.7      0.7 [   247/        0/     6][   247/        0/     6][   247/        0/     6] 0 0 0 */
/* eth1         6  ac:e2:d3:a1:53:33       0    247    235.7    235.7 [   247/        0/     6][   247/        0/     6][   247/        0/     6] 0 0 0 */
/* eth1         6  18:28:61:b0:d2:21       0    247    253.9    253.9 [   247/        0/     6][   247/        0/     6][   247/        0/     6] 0 0 0 */

                  num_col = sscanf(pline,"%s %*i %s %u %*i %u %u", dev, destMacStr, &metric, &age, &idle);
                  if(num_col > 0) { 
                          if(strstr(pline, "local") != NULL)
                                  route_list->routes[i].type = AUTOMESH_ROUTE_TYPE_LOCAL;
                          else if(strstr(pline, "discover") != NULL)
                                  route_list->routes[i].type = AUTOMESH_ROUTE_TYPE_LEARNED;
                          else if(strstr(pline, "hello") != NULL)
                                  route_list->routes[i].type = AUTOMESH_ROUTE_TYPE_DEFAULT;
                          else
                                  route_list->routes[i].type = AUTOMESH_ROUTE_TYPE_LEARNED;
  
			/* strncpy(route_list->routes[i].device, dev, IFNAMSIZ); */
			/* printf("ROUTE_TYPE:%d DEV:%s\n", route_list->routes[i].type, dev); */
                  }
		  i++;

          	/* k = strcspn(line, keys); */
		/* strncpy(str, line, k); */
		/* str[strlen(str)-1]='\n'; */
		/* printf("k:%d str:%s",k, str); */
		/* printf("str:%s",str); */
		/* printf("\n"); */

                  /* num_col = sscanf(pline,"%s %*i %s %u %*i %u %u", dev, destMacStr, &metric, &age, &idle); */
                  /* num_col = sscanf(str,"%s %*i %s %u %*i %u %u", dev, destMacStr, &metric, &age, &idle); */
		  /* printf("colnum:%d line:%s", num_col, pline); */
                  printf("%s %s %u %u %u\n", dev, destMacStr, metric, age, idle);
		/* memset(str,0,sizeof(str)); */
          }
  bail:
          if(fp != NULL)
                  fclose(fp);
          return ret;
}
